学习笔记

第一周~第十周学习总结

## 第一周

一、学习交流课

1.梳理自己的职业规划，理清自己的发展方向

2.职业成就方向

    (1)业务型成就
    (2)工程型成就
    (3)技术难题成就

3.学习方法

    (1)整理法
    (2)追溯法

二、第一周 编程与算法训练

1.前端实现 TicTacToe 游戏及 AI

    (1) 先分析后实现，一步一步循序渐进实现功能
    (2) 不同的写法的优点与缺点

2.学习前端异步编程方案

    (1) setTimeout
    (2) promise
    (3) generator
    (4) async/await

第一周 winter 老师教授了一些好的学习方法，同时在正课的学习中学会实现了 TicTacToe 游戏和简单的 AI,然后利用从 TicTacToe 游戏实现中学到的算法实现了五子棋的基本输赢判断，再结合分数权重方案实现了五子棋的 AI 算法。

## 第二周

一、地图编辑器

    1.对于display:inline-block间距问题可对父元素添加 font-size:0 解决

二、广度优先搜索

    1.通过从开始节点遍历周围的节点一步一步地寻找到最终的目标节点为止。
    2.其中利用队列的特性暂存遍历的节点，然后通过循环判断的方式一一对节点进行处理。

三、启发式搜索

    1.在原有广度优先搜索的基础之上,在插入节点时，传入节点的前驱节点，并将前驱节点存入map映射出的table节点中，最后通过遍历前驱节点的集合来找到对应的路径。

四、启发式搜索\*

    1.在启发式搜索的基础上，通过加入Sorted类的数据结构来对遍历的节点进行最佳路径的节点过滤。
    2.Sorted同时也替换掉了queue的对应操作，使得找到了最佳路径。

第二周的算法训练课中通过老师循序渐进的方式，我学会了利用搜索算法实现了寻路的功能，并且一步一步地优化算法的结构，最后得到了最优的解决方案，无论学习什么都是需要从易到难一步一步地去实现才能更好的将知识变成自己的东西的。

## 第三周

一、运用正则表达式判断四则表达式中的字符类型

二、运用 generator 返回迭代器的方式返回表达式类型的对象集合

三、从集合中设定的类型来判断对象类型，同时递归的方式将类型集合重组为一个节点的表达式解析集合

第三周的算法训练课是通过学习 LL 算法构建抽象语法树，主要学习到了利用正则表达式解析四则运算表达式的字符串，然后再依次将其构建成各个表达式对象组成的表达式集合。

## 第四周

一、字典树

字典树是一种树形结构，是一种哈希树的变种，是一种用于快速检索的多叉树结构。

二、KMP 算法

KMP 算法是一种改进的字符串匹配算法，由 D.E.Knuth，J.H.Morris 和 V.R.Pratt 同时发现，因此人们称它为克努特--莫里斯--普拉特操作(简称 KMP 算法)。

三、Wildcard

第四周的算法课还是分析字符串的算法，学习到了字典树，kmp 算法等概念，知道了更多检索字符串的方式。

## 第五周

一、proxy 代理

    1.利用 proxy 代理对象，通过 get,set 方法配置对应的监听函数
    2.绑定对应的 dom 元素事件，共同完成数据的双向绑定

二、range 对象的拖拽应用

    1.通过鼠标mousedown,maousemove,mouseup事件共同完成拖拽功能

第五周的算法训练学习到了 proxy 的先关概念和用法，明白了如何利用 proxy 实现数据的双向绑定，利用 range 对象实现了调色板和拖拽的功能。

## 第六周

一、 JS 语言通识 | 泛用语言分类方法

1.语言分为形式语言和非形式语言。

    非形式语言，包括中文、英文等，语法格式没有严格限制。

    形式语言，计算机中的编程语言都是形式语言，可以分为许多种，这里介绍乔姆斯基谱系，分为 4 种类型，0 型为无限制文法，1 型为上下文相关文法，2 型为上下文无关文法，3 型为正则文法。

2.乔姆斯基谱系：是计算机科学中刻画形式文法表达能力的一个分类谱系，是由诺姆·乔姆斯基于 1956 年提出的。它包括四个层次：

    0- 型文法（无限制文法或短语结构文法）包括所有的文法。
    1- 型文法（上下文相关文法）生成上下文相关语言。
    2- 型文法（上下文无关文法）生成上下文无关语言。
    3- 型文法（正规文法）生成正则语言。

二、JS 语言通识 | 什么是产生式
产生式： 在计算机中指 Tiger 编译器将源程序经过词法分析（Lexical Analysis）和语法分析（Syntax Analysis）后得到的一系列符合文法规则（Backus-Naur Form，BNF）的语句

    巴科斯诺尔范式：即巴科斯范式（英语：Backus Normal Form，缩写为 BNF）是一种用于表示上下文无关文法的语言，上下文无关文法描述了一类形式语言。它是由约翰·巴科斯（John Backus）和彼得·诺尔（Peter Naur）首先引入的用来描述计算机语言语法的符号集。

    终结符： 最终在代码中出现的字符（ https://zh.wikipedia.org/wiki/ 終結符與非終結符)

三、JS 语言通识 | 编程语言的性质

    图灵完备性：在可计算性理论里，如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟单带图灵机，那么它是图灵完全的。这个词源于引入图灵机概念的数学家艾伦·图灵。虽然图灵机会受到储存能力的物理限制，图灵完全性通常指“具有无限存储能力的通用物理机器或编程语言”。

    图灵机（Turing machine）：又称确定型图灵机，是英国数学家艾伦·图灵于 1936 年提出的一种将人的计算行为抽象掉的数学逻辑机，其更抽象的意义为一种计算模型，可以看作等价于任何有限逻辑数学过程的终极强大逻辑机器。

    静态和动态语言： https://www.cnblogs.com/raind/p/8551791.html

    强类型： 无隐式转换

    弱类型： 有隐式转换

    协变与逆变： https://jkchao.github.io/typescript-book-chinese/tips/covarianceAndContravariance.html

四、js 中的对象

1.对象类型

    String
    Number
    Boolean
    Object
    undefined
    null
    Symbol
    bigInt

2.对象三要素

    唯一标识、状态、行为

第六周重学 javascript 对 javascript 的句式和对象进行了深入的学习，让我对 javascript 有了更加深入的认识，同时也对平时写代码时不解的问题有了一个从原理上的深刻认识，对 javascript 的基础知识有了一个全面展开。

## 第七周

一、运算符和表达式

    1.Member 运算符从右开始运算
    2.new运算符高于 ()
    3.引用类型Reference(标准中类型)
    4.大多数运算符会进行类型转换后再计算，如 + - * / === !==
    5.**运算符在没括号情况下右优先
    6.三目运算符 ? : 存在短路原则

二、类型转换

    1.7种基本数据类型之间都存在互相转换
    2.存在装箱操作的几种数据类型：Number,String,Boolean,Symbol

三、运行时相关概念

    1.js语句：简单语句，复合语句，声明
    2.完成类型：normal,return,throw,break,continue

四、简单语句与复合语句

    1.简单语句: expression,empty,debugger,throw,continue,break,return
    2.复合语句: block,if,switch,iteration,with,labelled,try
    3.try{}catch{}finally{} try中执行return语句，finally块最终依然会执行

五、声明

    1.声明类型: funtion ,function*,async function,async funxction*,var,class,let,const
    2.所有的声明都会预处理
    3.{}可快速构建稳定的作用域

六、宏任务与微任务

    1.宏任务：传给js引擎的任务
      微任务：js引擎内部的任务（promise）
    2.事件循环就是宏任务和微任务不断变换执行的过程

七、js 函数调用

    1.函数调用为栈式调用
    2.Realm：存所有内置对象

第七周重学 javascript 对 js 的表达式、类型转换、申明、任务、函数等进行了深入的学习，不仅仅停留在表面的使用之上，而是从深层去剖析各个知识点，从中学习到了很多基本的实现原理，以后也可以少走更多的弯路。

## 第八周

一、有限状态机

    1.状态机以函数实现对各个状态之间的互相转换来实现对应需求，过程中思路十分清晰。

二、http 请求

    1.先通过node  http 模块创建一个服务端,实现接收和响应http请求。
    2.创建request类实现对传入config配置的初始化。
    3.通过net.createConnection创建TCP连接与服务端连接。
    4.利用状态机模式处理response中的headers信息

第八周分 2 部分，先是通过字符的搜索算法循序渐进地学习有限状态机的工作原理，之后在 http 的部分通过 node 实现了基本的 http 请求，为后面的 dom 解析做好了铺垫工作。

## 第九周

HTML 解析

第一步

    为了方便文件管理， 把parser单独拆到文件中
    parseHTML接受HTML文本作为参数返回DON树

第二步

    我们用FSM来实现HTML的分析（状态机）
    在HTML的标准中，已经规定了HTML的状态
    Toy-Browser只挑选其中一部分状态，完成一个最简版本

第三步

    主要标签有： 开始标签、结束标签、自封闭标签

第四步

    在状态机中，除了状态迁移，还要加入业务逻辑
    我们在标签结束状态提交标签token

第五步

    属性分为单引号 双引号 无引号三种写法，因此需要比较多的状态
    处理方式和标签类似

第六步

    从标签构建DOM树的基本技巧就是使用栈
    遇到开始标签创建元素入栈，遇到结束标签出栈
    自封闭节点可视为入栈后立即出栈
    任何元素的父元素是他入栈前的栈顶

第七步

    文本节点与自封闭标签类似处理类似
    多个文本节点需要合并

CSS computing

第一步

    遇到style标签时，我们吧CSS规则保存起来
    这里我们调用了CSS Parser 来分析CSS规则
    这里我们必须要仔细的研究此库来分析CSS规则的样式

第二步

    当我们创建一个元素后，立即计算CSS
    理论上个当我们分析一个元素时， 所有css规则已经收集完毕
    在真实的浏览器中，可能遇到写在body的style标签，需要从新计算css的情况，这里我们忽略

第三步

    在computeCSS函数中，我们必须知道元素的所有父元素才能判断元素与规则是否匹配
    我们从上一步骤的stack，可以获取本元素的所有父元素
    因为我们首先获得的是 “当前元素” 所以我们获得和计算父元素的匹配顺讯是从内向外

第四步

    选择器也要从当前元素向外排列
    复杂选择器拆成针对单个元素的选择器，用循环匹配父元素队列

第五步

    根据选择器的类型和元素属性，计算是否与当前元素匹配
    这里仅仅只实现了三种基本选择器，实际的浏览器中要处理复合选择器

第六步

    一旦选择匹配，就应用选择器到元素上，形成computeStyle

第七步

    CSS规则根据specificity和后来优先规则覆盖
    speccificity是一个四元组，越左边权重越高
    一个CSS规则的specificity根据简单的选择器相加而成

第九周主要是利用有限状态机实现对服务端返回的 html 和 css 的解析工作。

## 第十周

一、浏览器排版

    1.根据横竖分主轴和交叉轴进行对应的排版处理

二、dom 树渲染

    1.遍历获取dom元素依次渲染

主要学习到了如何处理 flex 布局的排版，从元素的基本样式到主轴和交叉轴的计算对 flex 布局进行了完整的构建，最后利用 image 库在页面上渲染出图片。

# 学习总结

    通过第一到九周的学习，在老师的教学方式下一步一步地学习到了很多的东西，知识由浅入深让自己能够更好地吸收到知识的根本原理。开始的时候老师是用一个游戏开始的，很有趣，极大地提高了学习的趣味性，让我们可以很好地一直坚持学下去。
    前七周学习的都比较顺畅，第八周之后学习就感觉有点吃力，但知识充实，我自己学习地也不是特别好，我是需要反思的。希望在以后的学习中能改掉自己的缺点，迎难而上。
    这种每次跟着老师敲代码的，课后和大家完成作业打卡的方式还是十分受用的，对自己还是有很大提升的。
    在学习接下来的课程的同时，还是需要定期回顾之前学习的知识，巩固已经学到的知识体系，不浪费学习的过程。
